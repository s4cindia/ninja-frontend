In `@src/components/pdf/MatterhornSummary.example.tsx`:
- Around line 139-148: The component PDFAuditResultsExample uses broad any types
causing linter errors; replace them with the proper PDF audit types from your
types module: import the interface (e.g., PdfAuditResult and PdfIssue or the
actual names in your pdf types module) and change the component signature to
PDFAuditResultsExample: React.FC<{ pdfAuditResult: PdfAuditResult }>, and type
the issues array and matterhornCheckpoint (e.g., issue: PdfIssue and
issue.matterhornCheckpoint: string) inside handleCheckpointClick so
pdfAuditResult.issues.filter(...) uses strongly typed values instead of any.

In `@src/components/pdf/MatterhornSummary.tsx`:
- Around line 7-12: The imported type MatterhornSummary conflicts with the
component name; alias the imported type (e.g., import type { MatterhornSummary
as MatterhornSummaryType, MatterhornCategory, MatterhornCheckpoint,
MatterhornCheckpointStatus } ...) and update the props interface to use
MatterhornSummaryType (MatterhornSummaryProps.summary: MatterhornSummaryType);
apply the same aliasing change for the other occurrence referenced (the second
block around the component/props at lines ~149-156) so no identifier is
redeclared.

In `@src/components/pdf/PdfPageNavigator.example.tsx`:
- Around line 200-202: The AuditResultsPageExample component currently types its
prop pdfAuditResult as any; define a proper interface (e.g., PdfAuditResult)
matching the shape used in the component (fields referenced inside
AuditResultsPageExample) and replace the any with that interface on the prop
type; update the component signature export const AuditResultsPageExample:
React.FC<{ pdfAuditResult: PdfAuditResult }> and export or colocate the
PdfAuditResult type so consumers and the preview panel example can reuse it.

In `@src/components/pdf/PdfPageNavigator.tsx`:
- Line 182: The activeItemRef is never attached so the scroll-into-view effect
in PdfPageNavigator cannot find the active button; update the PageItem component
to accept and forward a ref to its underlying button (use React.forwardRef or
add a prop like buttonRef and attach it to the <button> element), then when
rendering PageItem inside PdfPageNavigator pass activeItemRef only for the
active page (e.g., <PageItem ref={activeItemRef} ...> or <PageItem
buttonRef={activeItemRef} ...>), ensuring activeItemRef.current points to the
active button for the existing scroll-into-view code to work.

In `@src/components/pdf/PdfPreviewPanel.example.tsx`:
- Around line 142-143: The AuditResultsExample component currently types its
prop pdfAuditResult as any; replace that with a proper type by either importing
and using an existing PdfAuditResult type (e.g., import { PdfAuditResult } from
"@/types/pdf.types") or by declaring a local interface that matches the shape
used by AuditResultsExample, then change the component signature to React.FC<{
pdfAuditResult: PdfAuditResult }> and update any internal usages to match the
chosen type.
- Line 253: The render uses a direct window.innerWidth check in the conditional
((showSidebar || window.innerWidth >= 1024) && ...) which causes SSR/hydration
and resize issues; remove the window-dependent check and instead rely on CSS
responsive utilities (e.g., Tailwind's lg:block / hidden classes on the sidebar
element) or, if JS-driven behavior is required, replace it with a safe resize
hook that sets component state (e.g., useWindowSize or a custom
useIsLargeScreen) and reference that state in the conditional; update the JSX
around showSidebar and the sidebar element (the conditional currently
controlling PdfPreviewPanel rendering) to use the CSS classes or the new hook
state so rendering is safe during SSR and reacts to resizes.

In `@src/components/pdf/PdfPreviewPanel.test.tsx`:
- Line 2: The import list in PdfPreviewPanel.test.tsx includes an unused symbol
`waitFor`; remove `waitFor` from the named imports so the line imports only
`render`, `screen`, and `fireEvent` to satisfy static analysis and avoid
unused-import warnings.

In `@src/components/pdf/PdfPreviewPanel.tsx`:
- Around line 70-81: parseIssueLocation currently ignores its PdfAuditIssue
parameter and always returns null, causing no highlights and a lint unused-param
error; implement parsing of coordinates from issue.elementPath or a location
string supporting formats like "Page 5, x:100 y:200 w:300 h:50" and "x:100,
y:200, width:300, height:50" and return an IssueHighlight object { page, x, y,
width, height } when present, otherwise return null; update any other occurrence
noted (lines ~153-156) to use the new parser and gate rendering of overlays on a
non-null IssueHighlight to avoid rendering when coordinates are missing.
- Around line 229-243: The "Fit Width"/"Fit Page" options set zoomLevel to
non-numeric strings but the render path treats non-numeric values as scale 1, so
either compute a real numeric scale for those modes or remove the options;
update the component to detect when zoomLevel === "fit-width" or "fit-page" and
compute a numeric scale (using container/paper dimensions) before passing it to
the PDF renderer (where scale is consumed, e.g., the code that reads zoomLevel
and computes scale for rendering), or alternatively drop those option values
from the <select> and only expose numeric ZOOM_LEVELS; ensure references to
zoomLevel, setZoomLevel, ZOOM_LEVELS and the renderer logic that converts
zoomLevel→scale are updated accordingly.
- Around line 323-379: The PDF viewer is currently blocked by the "!isLoading &&
!error" guard so Document never mounts; change the rendering condition to mount
the viewer whenever there is no error (i.e. replace the "!isLoading && !error"
check with just "!error") so Document (with props file={pdfUrl},
onLoadSuccess={handleDocumentLoadSuccess}, onLoadError={handleDocumentLoadError}
and its loading prop) can mount and run its callbacks to flip isLoading; keep
the existing top-level isLoading spinner and the Document's internal loading UI
as-is.

In `@src/components/remediation/IssueCard.example.tsx`:
- Around line 129-131: Replace the use of "any" in the PdfAuditResultsExample
props with a concrete type: declare or import a PdfAuditResult interface (e.g.,
including issues: PdfAuditIssue[]) and use React.FC<{ pdfAuditResult:
PdfAuditResult }>, ensuring PdfAuditIssue is defined (or a minimal interface) so
pdfAuditResult.issues is typed as PdfAuditIssue[]; update the
PdfAuditResultsExample signature and any related example types accordingly.

In `@src/components/remediation/IssueCard.tsx`:
- Around line 20-23: The current isPdfIssue type guard incorrectly returns true
if any of 'matterhornCheckpoint', 'pageNumber', or 'ruleId' exist (and 'ruleId'
is too generic), causing false positives; update isPdfIssue to check for more
specific PDF-only fields together (e.g., require both 'matterhornCheckpoint' and
'pageNumber' to exist) or, better, convert AuditIssue/PdfAuditIssue to a
discriminated union using a dedicated discriminant (e.g., a 'type' field) and
have isPdfIssue test that discriminant; locate the isPdfIssue function and
either tighten the property checks to use a conjunction of PDF-specific
properties or implement and use a discriminated 'type' field on the types.
- Around line 39-41: The IssueCard component declares and destructures a unused
prop named compact; remove it from the IssueCardProps type/interface and from
the destructuring in the IssueCard function signature (i.e., delete "compact"
from IssueCardProps and from the parameter list where showMatterhorn and compact
are destructured), and run type checks to ensure no other references to compact
remain—if a compact layout is desired instead, implement the layout logic inside
the IssueCard component and use the compact prop where rendering differs.

In `@src/pages/PdfAuditResultsPage.example.tsx`:
- Around line 191-235: The simulated useAuditStore mutates a plain object so
React won't re-render when setCurrentJobId is called and also triggers
prefer-const lint; replace the ad-hoc store with React state inside
WithStateManagementExample (e.g., useState or useReducer) and update
handleJobComplete to call the state setter instead of store.setCurrentJobId;
remove the mutable top-level state object and ensure AuditState-compatible types
are used for the state variable and setter so the Link renders when currentJobId
changes.

In `@src/pages/PdfAuditResultsPage.tsx`:
- Around line 592-599: The issue: IssueCard clicks don't update preview because
selectedIssueId isn't set from the list; fix by wiring the card click to call
the existing handleIssueSelect. In the filteredIssues.map where IssueCard is
rendered, add a prop (e.g., onClick or onSelect depending on IssueCard's API)
that calls handleIssueSelect(issue.id) so selecting a card updates
selectedIssueId and syncs the preview/current page; keep existing
handlePageClick usage for page navigation. Ensure you reference the IssueCard in
the filteredIssues.map and use handleIssueSelect to update selectedIssueId.
- Around line 190-196: The Biome lint warning is caused by returning a value
inside a forEach callback while computing uniqueWcagCriteria in the useMemo
block; update the implementation in uniqueWcagCriteria so you don't return from
forEach — e.g., iterate with for...of loops or use map/flatMap followed by Set
to collect criteria from auditResult.issues and each issue.wcagCriteria,
ensuring you only call Set.add and do not return values from the callback
(reference: uniqueWcagCriteria, useMemo, auditResult).

In `@src/services/api/pdfAuditApi.ts`:
- Around line 416-503: The Promise executor in createCancellablePolling uses an
async function (new Promise(async (resolve, reject) => ...)), which violates
no-async-promise-executor; extract the async polling logic into a separate async
helper (e.g., async function runPolling()) and call it from a non-async Promise
executor, wiring resolve/reject to runPolling()'s result (and still using
abortController and timeoutId). Ensure timeout setup/clearTimeout and abort
handling remain identical, and forward any errors from runPolling to reject so
behavior of getAuditStatus, getAuditResult, sleep, and PdfApiError handling is
preserved.